<html>
  <head>
    <style>
      * { margin:0; padding:0; } /* to remove the top and left whitespace */
    </style>
    <title>JS13KGAMES 2022</title>

  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    <script>
      let canvas = document.getElementById('myCanvas')
      canvas.globalAlpha = 1
      let emojiSize = 25
      canvas.n_sprites_h = Math.trunc(window.innerHeight/emojiSize)
      canvas.n_sprites_w = Math.trunc(window.innerWidth/emojiSize)
      canvas.width = canvas.n_sprites_w * emojiSize
      canvas.height = canvas.n_sprites_h * emojiSize
      let context = canvas.getContext('2d')
      var level = []
      function Utils(){
        return {
          random: function(from,to){
            return Math.floor(Math.random() * (to - from + 1) + from)
          }
        }
      }
      class Sprite{
        constructor(){
          this.vel=5
          this.dir=''
        }
        //comunica anche se si sta usendo dalla scena
        collision(r1,x,y,s){
          if ((r1.posx < (x + s)) &&
              ((r1.posx + r1.size) > x) &&
              (r1.posy < (y + s)) &&
              ((r1.size + r1.posy) > y)) {
                return true
            }else{
              return false
            }
        }
        hit(x,y){
          if (x<0||y<0||(x+this.size)>canvas.width||(y+this.size)>canvas.height) return true
          let onStair = false; //use this variable to check if goUpAndDown is setted because I'm on stair or if it was setted previously
          for(let s = 0,l = level.length;s<l;s++){
            if (level[s].canGoThrough) { 
              this.goUpAndDown = true; 
              onStair = true;  
              return false 
            }
            let ret = this.collision(level[s],x,y,this.size)
            if(ret) {
              console.log('collision between hero and level sprite #'+s)
              return true
            }
          }
          for(let s = 0,l = sprites.length;s<l;s++){
            if(s!=this.arrayIndex){
              let ret = this.collision(sprites[s],x,y,this.size)
              if(ret) {
                console.log('collision between hero and hero sprite #'+s)
                return true
              }
            }
            
          }
          if(this.goUpAndDown && !onStair) delete this.goUpAndDown
          return false
          
        }
        up(){
          if (!this.hit(this.posx,this.posy-this.vel)){
            this.defaultEmoji()
            this.posy-=this.vel
          }else{
            this.hitEmoji()
          }
          //else this.posy+=5
        }
        down(){
          if (!this.hit(this.posx,this.posy+this.vel)){
            this.defaultEmoji()
            this.posy+=this.vel
          }else{
            this.hitEmoji()
          }
          //else this.posy-=5
        }
        right(){
          if (!this.hit(this.posx+this.vel,this.posy)){
            this.defaultEmoji()
            this.posx+=this.vel
          }else{
            this.hitEmoji()
          }
          //else this.posx-=5
        }
        left(){
          if (!this.hit(this.posx-this.vel,this.posy)){
            this.defaultEmoji()
            this.posx-=this.vel
          }else{
            this.hitEmoji()
          }
          //else this.posx+=5
        }
        jump(){
          if (this.j) {
            if (!this.iterator) this.iterator = this.jumpSizeYield(0)
            let jv = this.iterator.next().value
            if(jv) { 
              if (!this.hit(this.posx,this.posy+jv)){
                this.posy+=jv 
              }
            }
            else {
              delete this.iterator
              delete this.j
            }
          }
        }
        updatePosition(){}
        draw = function(){
          context.font = this.size + 'px serif'
          context.strokeStyle = 'black' 
          this.updatePosition()         
          this.drawSprite()
        }
        drawSprite(){
          context.fillText(this.emoji, this.posx-4,this.posy+this.size-3)
          context.rect(this.posx,this.posy,this.size,this.size)
          context.stroke()
        }
      }
      
      class WaterDrop extends Sprite{
        constructor(){
          super()
          this.size = emojiSize
          this.posy = canvas.height-this.size//Utils().random(0,Math.trunc(canvas.height/this.size)-1)*this.size
          this.posx = Utils().random(0,Math.trunc(canvas.width/this.size)-1)*this.size
          this.emoji = 'ðŸ’§'
        }
        drawSprite(){
          context.fillText(this.emoji, this.posx,this.posy+this.size-3)
          context.rect(this.posx,this.posy,this.size,this.size)
          context.stroke()
        }
      }
      class Stair extends Sprite{
        constructor(){
          super()
          this.size = emojiSize
          this.canGoThrough=true
          this.posy = canvas.height-this.size//Utils().random(0,Math.trunc(canvas.height/this.size)-1)*this.size
          this.posx = Utils().random(0,Math.trunc(canvas.width/this.size)-1)*this.size
          this.emoji = 'ðŸªœ'
        }
      }
      
      class BrownSquare extends Sprite{
        constructor(){
          super()
          this.size = emojiSize
          this.posy = canvas.height-this.size//Utils().random(0,Math.trunc(canvas.height/this.size)-1)*this.size
          this.posx = Utils().random(0,Math.trunc(canvas.width/this.size)-1)*this.size
          this.emoji = 'ðŸŸ«'
        }
        
      }
      class Hero extends Sprite{
        constructor(){
          super()
          this.size = emojiSize
          this.posx = 0
          this.posy = canvas.height-this.size
          this.dir=''
          this.emoji = 'ðŸ˜€'
          this.jumpSize = [-15,-10,-5,-2,-1,-1,-1,1,1,1,2,5,10,15]
          
          this.jumpSizeYield = function*(index) {
            while (index < this.jumpSize.length) {
              yield this.jumpSize[index]
              index++
            }
          }
          

        }
        defaultEmoji(){
          this.emoji = 'ðŸ˜€'
        }
        hitEmoji(){
          this.emoji = 'ðŸ˜µ'
        }
        updatePosition = function(){
          switch(this.dir){
            case 'u':
              this.up()
              break
            case 'd':
              this.down()
              break
            case 'r':
              this.right()
              break
            case 'l':
              this.left()
              break
          }
          if (this.j) {
            this.jump()
          }else{
            if(this.dir != 'u') this.down()
          }    
          
              
        }

      }
      let sprites = []
      let hero = new Hero()
      sprites.push(hero)
      level.push(new BrownSquare())
      level.push(new WaterDrop())
      level.push(new Stair())

      hero.arrayIndex = sprites.length-1
      
      function gameDraw(frame){
        canvas.width = canvas.width
        level.forEach(e => e.draw())
        sprites.forEach(e => e.draw())
        requestAnimationFrame(gameDraw)
      }

      function keydown(e){
        e = e || window.event;

        if (e.keyCode == '38') {
            hero.dir = 'u'// up arrow
        }
        else if (e.keyCode == '40') {
            hero.dir = 'd'// down arrow
        }
        else if (e.keyCode == '37') {
            hero.dir = 'l'// left arrow
        }
        else if (e.keyCode == '39') {
            hero.dir = 'r'// right arrow
        }
        else if (e.keyCode == '32') {
            hero.j = 'y'// jump arrow
            hero.js = hero.jumpSize //counter to jump up
            hero.jsd = hero.jumpSize //counter to jump down
        }
      }

      function keyup(e){
        e = e || window.event;

        if(e.keyCode != 32)hero.dir = ''
      }

      window.addEventListener('keydown',keydown)
      window.addEventListener('keyup',keyup)

      requestAnimationFrame(gameDraw)
    </script>
  </body>
</html>
