<html>
  <head>
    <style>
      * { margin:0; padding:0; } /* to remove the top and left whitespace */
      #info{
        position: absolute;
        left: 0px;
        /*top: 0px;*/
        z-index: -1;
      }
    </style>
    <title>JS13KGAMES 2022</title>

  </head>
  <body>
    <canvas id="bar"></canvas>
    <canvas id="myCanvas"></canvas>
    <canvas id="info"></canvas>
    
    <script>
      let canvas = document.getElementById('myCanvas')
      let info = document.getElementById('info')
      let bar = document.getElementById('bar')

      canvas.globalAlpha = 1
      let emojiSize = 25
      canvas.n_sprites_h = Math.trunc(window.innerHeight/emojiSize)
      canvas.n_sprites_w = Math.trunc(window.innerWidth/emojiSize)
      
      canvas.width = info.width = bar.width = (canvas.n_sprites_w * emojiSize)
      canvas.height = (canvas.n_sprites_h-1) * emojiSize
      let spazioPerSacchetto = (window.innerHeight - canvas.height)
      info.height = (canvas.n_sprites_h-1) * emojiSize
      bar.height = spazioPerSacchetto
      info.style.top = spazioPerSacchetto

      let context = canvas.getContext('2d')
      let infoCtx = info.getContext('2d')
      let barCtx = bar.getContext('2d')
      let debug = true
      var level = []
      function Utils(){
        return {
          random: function(from,to){
            return Math.floor(Math.random() * (to - from + 1) + from)
          }
        }
      }
      class Bar{
        constructor(ctx){
          this.context = ctx
          this.poketList = []
        }
        add(e){
          this.poketList.push(e)
        }
        draw(){
          bar.width = bar.width
          let x = 0, y = 0
          this.poketList.forEach((e) => {
            e.draw(x,y)
            x+=emojiSize+5
          })
        }
        hasSedds(){
          return this.poketList.filter(e => e instanceof Seed).length
        }
        removeSeed(){
          for(let i = 0, a_l=this.poketList.length; i < a_l; i++)
            if (this.poketList[i] instanceof Seed){
              this.poketList.splice(i,1)
              return
            }
        }

      }
      let barEl = new Bar(barCtx)
      class Sprite{
        constructor(ctx){
          this.vel=5
          this.dir=''
          this.visible=true
          this.ts=0
          this.timeEffect=0
          this.seedCounterEmoji=['0ï¸âƒ£','1ï¸âƒ£','2ï¸âƒ£','3ï¸âƒ£','4ï¸âƒ£','5ï¸âƒ£','6ï¸âƒ£','7ï¸âƒ£','8ï¸âƒ£','9ï¸âƒ£']
          this.context = ctx
        }
        //comunica anche se si sta usendo dalla scena
        collision(r1,x,y,s){
          if(r1.visible == true)
            if ((r1.posx < (x + s)) &&
                ((r1.posx + r1.size) > x) &&
                (r1.posy < (y + s)) &&
                ((r1.size + r1.posy) > y)) {
                  return true
              }else{
                return false
              }
            else return false
        }
        hitReaction(){}//decido cosa succede quando lo sprite viene colpito
        getHitEmoji(){}//l'oggetto che mi colpisce che emoji avrÃ ?
        hit(x,y){
          if (x<0||y<0||(x+this.size)>canvas.width||(y+this.size)>canvas.height) return {emoji:this.emoji,ret:true}
          let onLadder = false; //use this variable to check if goUpAndDown is setted because I'm on Ladder or if it was setted previously
          this.goUpAndDown = false
          console.log(this)
          for(let s = 0,l = level.length;s<l;s++){
            if (level[s].visible){
              let ret = this.collision(level[s],x,y,this.size)
              if(ret) {
                console.log('collision between hero and level sprite #'+s)
                if (level[s].canGoThrough) { 
                  this.goUpAndDown = true
                  onLadder = true  
                  return {emoji:this.emoji,ret:false}
                }
              
                level[s].hitReaction()
                return {emoji:level[s].getHitEmoji(this),ret:true}
              }
            }
            
          }
          for(let s = 0,l = sprites.length;s<l;s++){
            if(!(sprites[s].constructor === this.constructor)){
              if(s!=this.arrayIndex){
                let ret = this.collision(sprites[s],x,y,this.size)
                if(ret) {
                  console.log('collision between hero and hero sprite #'+s)
                  return {emoji:this.emoji,ret:true}
                }
              }
            }
            
            
          }
          console.log(this.goUpAndDown, onLadder)
          if(this.goUpAndDown && !onLadder){
            delete this.goUpAndDown
            
          } 
          if(!this.goUpAndDown && !onLadder && this.dir == 'u'){
            if(!this.doOneStep){
              this.doOneStep = true
              return {emoji:this.emoji,ret:false}
            }else{
              return {emoji:this.emoji,ret:true}    
            }
            
          }
          return {emoji:this.emoji,ret:false}
          
        }
        up(){
          let ret = this.hit(this.posx,this.posy-this.vel)
          if (ret.ret == false){
            this.posy-=this.vel
          }else{
            this.emoji = ret.emoji
          }
        }
        down(){
          let ret = this.hit(this.posx,this.posy+this.vel)
          if (ret.ret == false){
            //this.defaultEmoji()
            this.posy+=this.vel
          }else{
            this.emoji = ret.emoji

          }
          //else this.posy-=5
        }
        right(){
          let ret = this.hit(this.posx+this.vel,this.posy)
          if (ret.ret == false){
            //this.defaultEmoji()
            this.posx+=this.vel
          }else{
            this.emoji = ret.emoji

          }
          //else this.posx-=5
        }
        left(){
          let ret = this.hit(this.posx-this.vel,this.posy)
          if (ret.ret == false){
            //this.defaultEmoji()
            this.posx-=this.vel
          }else{
            this.emoji = ret.emoji

          }
          //else this.posx+=5
        }
        jump(){
          if (this.j) {
            if (!this.iterator) this.iterator = this.jumpSizeYield(0)
            let jv = this.iterator.next().value
            if(jv) {
              let ret = this.hit(this.posx,this.posy+jv) 
              if (ret.ret == false){
                this.posy+=jv 
              }else{
                this.emoji = ret.emoji

              }
            }
            else {
              delete this.iterator
              delete this.j
            }
          }
        }
        updatePosition(){}
        draw = function(x,y){
          this.context.font = this.size + 'px serif'
          this.context.strokeStyle = 'black' 
          this.updatePosition()         
          this.drawSprite(x,y)
        }
        whatHappenAfterCollisionTS(){
          this.emoji = this.defaultEmoji()
        }
        drawSprite(x,y){
          if(this.ts){
            let now = Date.now()
            let diff = now-this.ts
            if(Math.round(diff/1000)>this.timeEffect) {
              this.ts = 0
              this.whatHappenAfterCollisionTS()
            }
          }
          if(x||x==0)this.posx=x
          if(y||y==0)this.posy=y
          this.context.fillText(this.emoji, this.posx-4,this.posy+this.size-3)
          if(debug)this.context.rect(this.posx,this.posy,this.size,this.size)
          this.context.stroke()
        }
      }
      class Seed extends Sprite {
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.posy = y
          this.posx = x
          this.emoji = 'ðŸ¦´'
          this.dir = ''
        }
        updatePosition(){
          switch(this.dir){
            case 'r':
              this.right()
              break
            case 'l':
              this.left()
              break
          }    
        }
        whatHappenAfterCollisionTS(){
          this.visible = false
        }

      }
      
      class Bone extends Sprite{
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.posy = y
          this.posx = x
          this.emoji = 'ðŸ¦´'
        }
        hitReaction(){
          this.visible=false
          let numberOfSeeds = barEl.hasSedds()
          for(let i = numberOfSeeds;i<6;i++) barEl.add(new Seed(barCtx,0,0))
        }
        getHitEmoji(o){
          /*
          if(o instanceof Hero){
            o.seedCounter = 6
            o.ts = 0
            return o.seedCounterEmoji[o.seedCounter]
          }
          */
         return 'ðŸ’€'
        }
        drawSprite(){
          this.context.fillText(this.emoji, this.posx-3,this.posy+this.size-3)
          this.context.rect(this.posx,this.posy,this.size,this.size)
          this.context.stroke()
        }
      }
      class WaterDrop extends Sprite{
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.posy = y
          this.posx = x
          this.emoji = 'ðŸ’§'
        }
        hitReaction(){
          this.visible=false
        }
        getHitEmoji(o){
          if(o instanceof Hero){//hit by hero
            o.ts = Date.now()//set ts
            o.timeEffect = 2//time render of the emoji setted below
            return 'ðŸ˜“'
          }
        }
        drawSprite(){
          this.context.fillText(this.emoji, this.posx-5,this.posy+this.size-3)
          this.context.rect(this.posx,this.posy,this.size,this.size)
          this.context.stroke()
        }
      }
      class Ladder extends Sprite{
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.canGoThrough=true
          this.posy = y
          this.posx = x
          this.emoji = 'ðŸªœ'
        }
      }
      
      class headstone extends Sprite{
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.posy = y
          this.posx = x
          this.emoji = 'ðŸª¦'
        }
        getHitEmoji(o){
          if(!o.ts)o.ts = Date.now()
          if(o instanceof Hero){
            o.timeEffect = 3
            return 'ðŸ’€'
          }
          if(o instanceof Seed){
            o.timeEffect = 1//time render of explosion
            return 'ðŸ’¥'
          }
        }
      }
      class brick extends Sprite{
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.posy = y
          this.posx = x
          this.emoji = 'ðŸ§±'
        }
        getHitEmoji(o){
          if(!o.ts)o.ts = Date.now()
          if(o instanceof Hero){
            o.timeEffect = 3
            return 'ðŸ’€'
          }
          if(o instanceof Seed){
            o.timeEffect = 1//time render of explosion
            return 'ðŸ’¥'
          }
        }
      }
      class Hero extends Sprite{
        constructor(ctx,x,y){
          super(ctx)
          this.size = emojiSize
          this.posx = x
          this.posy = y
          this.dir=''
          this.emoji = 'ðŸ’€'
          this.jumpSize = [-15,-10,-5,-2,-1,-1,-1,1,1,1,2,5,10,15]
          this.seedCounter = 0

          this.jumpSizeYield = function*(index) {
            while (index < this.jumpSize.length) {
              yield this.jumpSize[index]
              index++
            }
          }
          

        }
        defaultEmoji(){
          return 'ðŸ’€'
        }
        hitEmoji(){
          this.emoji = 'ðŸ’€'
        }
        updatePosition(){
          switch(this.dir){
            case 'u':
              this.up()
              break
            case 'd':
              this.down()
              break
            case 'r':
              this.right()
              break
            case 'l':
              this.left()
              break
          }
          if (this.j) {
            this.jump()
          }else{
            if(this.dir != 'u') this.down()
          }    
          
              
        }

      }
      let sprites = []
      let posx = 0
      let posy = canvas.height-emojiSize
          
      let hero = new Hero(context,posx,posy)
      sprites.push(hero)
      posy = canvas.height-emojiSize//Utils().random(0,Math.trunc(canvas.height/this.size)-1)*this.size
      posx = Utils().random(0,Math.trunc(canvas.width/emojiSize)-1)*emojiSize
      level.push(new headstone(context,posx,posy))
      //posx = Utils().random(0,Math.trunc(canvas.width/emojiSize)-1)*emojiSize
      //level.push(new WaterDrop(context,posx,posy))
      //posx = Utils().random(0,Math.trunc(canvas.width/emojiSize)-1)*emojiSize
      level.push(new Ladder(context,posx+25,posy))
      level.push(new Ladder(context,posx+25,posy-25))
      level.push(new brick(context,posx+50,posy-25))
      level.push(new Ladder(context,posx+25,posy-50))

      posx = Utils().random(0,Math.trunc(canvas.width/emojiSize)-1)*emojiSize
      level.push(new Bone(context,posx,posy))
      //posx = Utils().random(0,Math.trunc(canvas.width/emojiSize)-1)*emojiSize
      //level.push(new Bone(infoCtx,posx,posy))

      //barEl.add(new Bone(barCtx,0,0))


      hero.arrayIndex = sprites.length-1
      
      function gameDraw(frame){
        canvas.width = canvas.width
        level.filter(e => e.visible).forEach(e => e.draw())
        sprites.filter(e => e.visible).forEach(e => e.draw())
        barEl.draw()
        requestAnimationFrame(gameDraw)
      }

      function keydown(e){
        e = e || window.event
        if (e.keyCode == '38') {
          //if(hero.goUpAndDown){
            hero.dir = 'u'// up arrow
            hero.oldDir = 'u'
          //}
        }/*else if (e.keyCode == '40') {
            hero.dir = 'd'// down arrow
            hero.oldDir = 'd'
        }*/
        else if (e.keyCode == '37') {
            hero.dir = 'l'// left arrow
            hero.oldDir = 'l'
        }
        else if (e.keyCode == '39') {
            hero.dir = 'r'// right arrow
            hero.oldDir = 'r'
        }
        else if (e.keyCode == '32') {
            hero.j = 'y'// jump arrow
            hero.js = hero.jumpSize //counter to jump up
            hero.jsd = hero.jumpSize //counter to jump down
        }else if (e.keyCode == '90') {
          if(barEl.hasSedds()){
            let sx
            let sy = hero.posy 
            if(hero.oldDir == 'r'){
              sx = hero.posx+hero.size
            }else if(hero.oldDir == 'l'){
              sx = hero.posx-hero.size
            }
            let seed = new Seed(context,sx,sy)
            seed.dir = hero.oldDir//se non sto premendo la direzione so almeno dove sto guardando            
            sprites.push(seed)  
            barEl.removeSeed()
          }
          
        }
      }

      function keyup(e){
        e = e || window.event;

        if(e.keyCode != 32)hero.dir = ''
      }

      window.addEventListener('keydown',keydown)
      window.addEventListener('keyup',keyup)

      requestAnimationFrame(gameDraw)
    </script>
  </body>
</html>
